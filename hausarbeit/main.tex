\documentclass[a4paper,11pt]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% \fontfamily{pzc}\selectfont
% \ttfamily

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize\fontfamily{bch}\selectfont,        
  % the size & type of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={min,max},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Python,                 % the language of the code
  morekeywords={},                 % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
%   title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


% Add new keywords here: ConfigManip, Parameters…
\lstset{emph={%  
    IntegerParameter, ConfigurationManipulator,EnumParameter,format,call_program%
    },emphstyle={\textbf}%
}%


\newcommand{\zB}{\mbox{z.\,B.}\xspace}
\newcommand{\bspw}{\mbox{bspw.}\xspace}
\newcommand{\iAllg}{\mbox{i.\,Allg.}\xspace}
\newcommand{\ua}{\mbox{u.\,a.}\xspace}
\newcommand{\vs}{\mbox{vs.}\xspace}

\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}
\setlength{\parindent}{0em} % Einrückung verhindern

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
\title{\includegraphics[width=0.6\textwidth]{bilder/tuc-logo-black.pdf}
    OpenTuner:~An~Extensible~Framework\\for~Program~Autotuning
}
\author{Seminararbeit\\Autor: Matthias Tietz}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle \thispagestyle{empty} \newpage

%%% Informationen/Leerseite %%%
\thispagestyle{empty}
~
\vfill
Technische Universität Chemnitz\\
Fakultät für Informatik\\
Professur Praktische Informatik\\
Hauptseminar Multicore-Programmierung\\
Wintersemester 2016/2017\\

OpenTuner: An Extensible Framework for Program Autotuning\\
Autor: Matthias Tietz\\
Matrikelnummer:~375681\\
Bachelor Informatik, 5.~Fachsemester

\newpage
\tableofcontents \newpage

%%%%%%%%
%% TODO: Kopfzeile Information der aktuellen Section ??
%%%%%%%%

%%%%%%%%
%% TODO: Sichtwortverzeichnis? : Autotuner, Param, Konfig, ...
%%%%%%%%

%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Einleitung}
% sub: Related Work, Begriffe

Programm-Autotuning findet zunehmend Anwendung in Domänen wie Hochleistungsrechnen oder
digitaler Bild-~und~Signalverarbeitung zur Optimierung der entsprechenden Anwendung.
Durch die Verwendung eines Autotuners besteht die Möglichkeit, die Suche nach der
bestmöglichen Programm-Implementierung zu automatisieren. Anstatt ein Programm direkt
zu optimieren, beschreibt der Nutzer eine Menge möglicher Implementierungen, die 
systematisch von geeigneten Techniken durchsucht wird. Das Optimierungsverfahren
mittels Autotuner ist zumeist effizienter als die Optimierung von Hand, da deutlich größere
Suchräume verarbeitet werden können. \newline

Bei der Erstellung eines Autotuners steht oftmals die Verbesserung der Laufzeit
für das spezifische Programm im Vordergrund. OpenTuner bietet neben \texttt{time}\footnote{Zeit, Ausführungszeit}  
alternativ weitere Optimierungsziele, \zB \texttt{accuracy}\footnote{Genauigkeit, \zB Genauigkeit einer Berechnung}  
und \texttt{energy}\footnote{Energie, Energiebedarf eines bestimmten Systems}.
Es ist außerdem möglich, mehrere Ziele bei der Optimierung zu verfolgen. 
So kann man \bspw das Optimierungsziel \texttt{time-accuracy} definieren, also die Ausführungszeit
des Programms verbessern und gleichzeitig die Genauigkeit berücksichtigen. \newline

Bestehende Autotuning-Frameworks wurden \iAllg zielgerichtet für den Einsatz in einer 
bestimmten Domäne entwickelt. \textsc{ATLAS} \cite{atlas} ist ein Projekt aus dem Bereich der Linearen Algebra,
\textsc{FFTW} \cite{fftw} verwendet Autotuning zum Lösen schneller Fourier-Transformationen.
Im Gegensatz dazu verfolgt OpenTuner den Ansatz, ein generelles System zur Erstellung 
von Autotunern für verschiedene Domänen einzuführen. Diese Flexibilität wird grundsätzlich durch eine stark
ausgeprägte Erweiterbarkeit und einen großen Funktionsumfang des Frameworks ermöglicht.
Das durch OpenTuner realisierte Optimierungsverfahren kann auf andere Rechnersysteme übertragen
und mit den dort existierenden Bedingungen wiederholt werden. \newline

Bei der Entwicklung eines Autotuning-Frameworks existieren drei grundsätzliche Herausforderungen.
Zunächst die Möglichkeit für einen Problemfall eine \emph{passende Konfigurations-Repräsentation} wählen
zu können. Das umfasst die Darstellung der notwendigen Datenstrukturen und Bedingungen. Eine gute 
Repräsentation ist entscheidend für die Effizienz des Autotuners. Ebenso kritisch kann die 
\emph{Größe des gültigen Suchraumes} sein, denn durch Kombination verschiedener Parameter sind 
schnell rießige Suchräume möglich. Eine vollständige Suche würde dort oftmals nicht abschließen,
daher bedarf es intelligenter Suchtechniken, welche nur einen kleinen Teil der Konfigurationsmenge
durchsuchen, um ein gutes Ergebnis zu erzielen. Die \emph{Beschaffenheit des Suchraumes} stellt
ebenfalls eine Herausforderung dar, da in vielen praktischen Anwendungen die Suchräume meist ein
hohes Maß an Komplexität besitzen.

%%% ein wenig kürzen %%%

%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{OpenTuner Framework}
Die Architektur des Frameworks ist vergleichsweise kompakt und lässt sich in die folgenden drei 
Komponenten gliedern: Suche, Messung und Ergebnis-Datenbank.

\begin{figure}[h]
\begin{center}
\includegraphics{bilder/smdb}
\cite{OT-paper} \caption{Komponenten des OpenTuner Framework} 
\end{center}   
\end{figure}

Die Menge der Suchtechniken verwendet den Konfigurations-Manipulator, um Konfigurationen lesen und 
schreiben zu können. Ausgewählte Konfigurationen werden durch eine benutzerdefinierte Messfunktion
ausgeführt und anschließend ausgewertet. Die Datenbank dient dem Festhalten der Ergebnisse des Tuning-Vorgangs
und dem Informationsaustausch zwischen Suche und Messung.

%%% ggf. noch Messungen parallel??? %%%

\subsection{Suchtechniken}
OpenTuner stellt im Auslieferungszustand grundlegende Suchtechniken bereit, die auf viele Arten von 
Suchräumen anwendbar sind. Die Verwendung der Suchtechniken findet hierarchisch statt --
die Suchsteuerung spricht eine \texttt{root technique}\footnote{zentrale Technik (sog.~Meta-Technik),
ist den normalen Suchtechniken/Heuristiken übergeordnet} an, die dann während des Tuning-Vorgangs 
Tests auf eine Menge von \texttt{sub-techniques}\footnote{die Standard-Suchtechniken} verteilt. 
Die \emph{Ensembles} sind ein Konzept von OpenTuner, welches die Kombination mehrerer Suchtechniken
ermöglicht. Einzelne Suchtechniken tauschen Ergebnisse über die Datenbank aus -- findet eine 
Suchtechnik eine gute Konfiguration, so können andere Techniken davon profitieren.
Suchtechniken bekommen ihre Testanteile dynamisch zugewiesen, abhängig davon wie erfolgreich eine
jeweils ist.

\subsection{Konfigurations-Manipulator}
Der Konfigurations-Manipulator stellt die Schnittstelle zwischen Suchtechniken und Konfigurationen
dar. Dieser verwaltet die Menge der Parameter inklusive der jeweiligen Belegung und regelt den Zugriff
(Lesen/Schreiben) durch die Suchtechniken.

\subsubsection{Parameter-Arten}

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.85\textwidth]{bilder/paramtypes}
\cite{OT-paper} \caption{Hierarchie der integrierten Parameter-Arten} 
\end{center}
\end{figure}

Primitive Parameter repräsentieren numerische Werte einschließlich einem dafür
zulässigen und definierbaren Wertebereich\footnote{untere und obere Grenze des Parameters}. 
Zusätzlich existieren Varianten dieser Parameter,
deren konkreter Wert skaliert nach außen gegeben wird. Für ein Anwendungsszenario mit 
stark wachsenden Parametergrößen bietet sich die logarithmische Skalierung an. \newline

Der komplexe Parameter \texttt{Permutation} erstellt für eine gegebene Liste von Werten dessen 
Reihenfolge und besitzt die Funktionalität zufällige Änderungen an dieser Ordnung vorzunehmen.
Für beide Parameter-Arten lassen sich bestehende Parameter erweitern oder einfach neue erstellen.

\subsection{Optimierungsziele}

OpenTuner unterstützt mehrere Optimierungsziele, standardmäßig wird nach der Zeit optimiert.
Ergänzend zu \texttt{time} kann \texttt{accuracy}, \texttt{energy}, \texttt{size}, 
\texttt{confidence} oder ein eigens vom Nutzer definiertes Ziel gewählt werden.
Darüber hinaus kann man bei der Optimierung mehr als ein Ziel gleichzeitig verfolgen und
Ziele nutzerspezifisch kombinieren (\zB \texttt{threshold accuracy  while
minimizing time}). 

\subsection{Suchen und Messen}

Das OpenTuner Framework besitzt die beiden Module \emph{Suchen} und \emph{Messen},
deren Kommunikation ausschließlich über die Ergebnis-Datenbank stattfindet.
Beim Entwurf von OpenTuner wurde sich bewusst dazu entschieden, diese zwei Komponenten
klar zu trennen. Diese Trennung hat \ua den Vorteil, dass mehrere Messungen parallel 
ausgeführt werden können. Da für den Großteil der Autotuning-Anwendungen der Messaufwand
den Suchaufwand deutlich übersteigt, ist die Unterteilung besonders sinnvoll.
Außerdem können dadurch Bestandteile wie \zB das Messmodul einfach erweitert oder 
ausgetauscht werden, ohne das zugrundeliegende Framework ändern zu müssen.


%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Verwendung}
Um mit OpenTuner einen Autotuner zu implementieren, sind folgende Schritte notwendig:
\begin{itemize}
  \item Suchraum definieren $\rightarrow$ \emph{configuration manipulator}
  \item Messfunktion erstellen (Konfigurationsauswertung) $\rightarrow$ \emph{run function}
  \item Festlegen des Optimierungsziels
\end{itemize}
Weitere Optionen lassen sich von außen an den Autotuner übergeben. So kann 
mit \texttt{./autotuner.py --parallelism=2} spezifiziert werden, wieviele Konfigurationen
(hier:~2) OpenTuner parallel auswerten soll. \newline

Da mit OpenTuner ein praxisorientierter Ansatz verfolgt wird, folgt nun eine Reihe von
Beispielen, in denen das Framework eingesetzt wird, um Anwendungen in unterschiedlicher 
Hinsicht zu optimieren. Für das jeweilige Beispiel wird der Problembereich beschrieben,
auf die Umsetzung des Autotuners eingangen und die erzielten Resultate mit denen bisheriger
Autotuner verglichen.

\subsection{Beispielhafte Anwendungen}
\subsubsection{GCC/G++ Flags}
Für diesen Anwendungsfall steht die Auswahl und Kombination von Compileroptionen
im Vordergrund. Der Autotuner soll eine Menge von Flags und Parametern durchsuchen,
um die resultierende Ausführungszeit des kompilierten Zielprogramms zu minimieren.
Die unterstützten Flags erhält man mit \texttt{g++ --help=optimizers}, die 
Parameter inklusive der zulässigen Wertebereich aus \texttt{params.def} (gcc source code). \newline

Die Umsetzung des Autotuners lässt sich ideal mit OpenTuner realisieren, denn der
Suchraum kann durch Verwendung primitiver Parameter ausreichend modelliert werden:
\begin{itemize}
  \item Optimierungslevel \texttt{(O0,$\ldots$,O3)} $\leftrightarrow$ \texttt{IntegerParameter~(min:~0, max:~3)}
  \item Flag $\leftrightarrow$ \texttt{EnumParameter~(on,~off,~default)}
  \item Parameter $\leftrightarrow$ \texttt{IntegerParameter~(min:~x, max:~y)}
\end{itemize}
Um die eigentliche Übersetzung mit einem Compiler durchführen zu können, sind konkrete
Zielprogramme notwendig. Für die Ergebnisse in diesem Beispiel wurde sich auf diese
Auswahl beschränkt: Schnelle Fourier-Transformation in C (\texttt{fft.c}) \cite{fftc} und 
ein Template zur Matrix-Multiplikation in \CC (\texttt{matrixmultiply.cpp}) \cite{mmcpp}. \newline

% kurze Überleitung zur Implementierung der Schritte 1-3 in Python
Die Implementierung des Autotuners geschieht anhand eines Python-Programms, da so die direkte Schnittstelle
zu OpenTuner spezifiziert ist. Es folgen nun repräsentative Code-Abschnitte, um eine
mögliche Umsetzung konkret nachvollziehen zu können.  \newline

\lstinputlisting[language=Python]{etc/2830.py}
Zunächst erstellt man eine neue Variable zur Repräsentation des Suchraums: \texttt{manipulator}.
Die standardmäßig unterstützten Optimierungslevel des GCC werden dem Konfigurations-Manipulator
als \texttt{IntegerParameter}, inklusive der zulässigen Grenzen, hinzugefügt. \newline

\lstinputlisting[language=Python]{etc/gccflags.py}
Der Suchraum wird nun durch die einzelnen GCC-Flags als Menge von \texttt{EnumParameter} 
erweitert. \newline

\lstinputlisting[language=Python]{etc/gccparams.py}
Nach Einfügen der GCC-Parameter ist der Suchraum vollständig und es kann der nächste Schritt,
die Definition der Messfunktion, folgen. \newline

\lstinputlisting[language=Python]{etc/run.py}
Um eine Messung ausführen zu können, ist dafür zunächst eine Konfiguration notwendig.
Diese Konfiguration wird durch die Variable \texttt{gcc\_cmd} repräsentiert, welche
schrittweise konkrete Parameterbelegungen hinzugefügt bekommt. \newline

\lstinputlisting[language=Python]{etc/flagsonoff.py}
Nun wird der Konfiguration die Information übertragen, ob das jeweilige GCC-Flag
aktiviert werden soll oder nicht, \zB~'-falign-functions' \vs~'-fno-align-functions'.

\lstinputlisting[language=Python]{etc/params.py}

\lstinputlisting[language=Python]{etc/measure.py}






%%%%%%%%%
% box um code bsp.: schritte 1,2,3 mit erklärung
% 2 <-> messfunktion
% ergebnisse: grafiken
%
%%%%%%%%%

\subsection{Ausprobieren der Techniken}

%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Fazit}
abc

%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Literaturverzeichnis}
% abc

\begin{thebibliography}{9}
   
  %%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%
  %  TODO: Zitatstile -> Reihenfolge: Autor, Titel, Jahr, Verlag, Seite, …
  %%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%
  
    \bibitem{OT-paper} Jason Ansel, Shoaib Kamil, Kalyan Veeramachaneni, Jonathan Ragan-Kelley, Jeffrey Bosboom, Una-May O'Reilly, Saman Amarasinghe. \emph{OpenTuner: An Extensible Framework for Program Autotuning.}
    2014.
   
\bibitem{atlas} Liste der Autoren \emph{Titel oder Quelle des zitierten Werkes} ggf. Seiten.
    Jahr. und weiteres.
\bibitem{fftw} Liste der Autoren \emph{Titel oder Quelle des zitierten Werkes} ggf. Seiten.
    Jahr. und weiteres.
\bibitem{fftc} SPLASH2 [35]Liste der Autoren \emph{Titel oder Quelle des zitierten Werkes} ggf. Seiten.
    Jahr. und weiteres.
\bibitem{mmcpp} Xiang Fan [11] Liste der Autoren \emph{Titel oder Quelle des zitierten Werkes} ggf. Seiten.
    Jahr. und weiteres.

\end{thebibliography}


% \section{Eigenständigkeitserklärung}
% abc

\end{document}
